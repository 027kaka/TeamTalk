// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: IM.Internal.proto

#ifndef PROTOBUF_IM_2eInternal_2eproto__INCLUDED
#define PROTOBUF_IM_2eInternal_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include "IM.BaseDefine.pb.h"
// @@protoc_insertion_point(includes)

namespace IM {
namespace Internal {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_IM_2eInternal_2eproto();
void protobuf_AssignDesc_IM_2eInternal_2eproto();
void protobuf_ShutdownFile_IM_2eInternal_2eproto();

class IMSyncAuthInfoReq;
class IMSyncAuthInfoRsp;
class IMGetUserIdListByNickNameReq;
class IMGetUserIdListByNickNameRsp;

// ===================================================================

class IMSyncAuthInfoReq : public ::google::protobuf::MessageLite {
 public:
  IMSyncAuthInfoReq();
  virtual ~IMSyncAuthInfoReq();

  IMSyncAuthInfoReq(const IMSyncAuthInfoReq& from);

  inline IMSyncAuthInfoReq& operator=(const IMSyncAuthInfoReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const IMSyncAuthInfoReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMSyncAuthInfoReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMSyncAuthInfoReq* other);

  // implements Message ----------------------------------------------

  IMSyncAuthInfoReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMSyncAuthInfoReq& from);
  void MergeFrom(const IMSyncAuthInfoReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 latest_time = 1;
  inline bool has_latest_time() const;
  inline void clear_latest_time();
  static const int kLatestTimeFieldNumber = 1;
  inline ::google::protobuf::uint32 latest_time() const;
  inline void set_latest_time(::google::protobuf::uint32 value);

  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.Internal.IMSyncAuthInfoReq)
 private:
  inline void set_has_latest_time();
  inline void clear_has_latest_time();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* attach_data_;
  ::google::protobuf::uint32 latest_time_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eInternal_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eInternal_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eInternal_2eproto();
  friend void protobuf_ShutdownFile_IM_2eInternal_2eproto();

  void InitAsDefaultInstance();
  static IMSyncAuthInfoReq* default_instance_;
};
// -------------------------------------------------------------------

class IMSyncAuthInfoRsp : public ::google::protobuf::MessageLite {
 public:
  IMSyncAuthInfoRsp();
  virtual ~IMSyncAuthInfoRsp();

  IMSyncAuthInfoRsp(const IMSyncAuthInfoRsp& from);

  inline IMSyncAuthInfoRsp& operator=(const IMSyncAuthInfoRsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const IMSyncAuthInfoRsp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMSyncAuthInfoRsp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMSyncAuthInfoRsp* other);

  // implements Message ----------------------------------------------

  IMSyncAuthInfoRsp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMSyncAuthInfoRsp& from);
  void MergeFrom(const IMSyncAuthInfoRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 latest_time = 1;
  inline bool has_latest_time() const;
  inline void clear_latest_time();
  static const int kLatestTimeFieldNumber = 1;
  inline ::google::protobuf::uint32 latest_time() const;
  inline void set_latest_time(::google::protobuf::uint32 value);

  // repeated .IM.BaseDefine.AuthInfo auth_list = 2;
  inline int auth_list_size() const;
  inline void clear_auth_list();
  static const int kAuthListFieldNumber = 2;
  inline const ::IM::BaseDefine::AuthInfo& auth_list(int index) const;
  inline ::IM::BaseDefine::AuthInfo* mutable_auth_list(int index);
  inline ::IM::BaseDefine::AuthInfo* add_auth_list();
  inline const ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::AuthInfo >&
      auth_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::AuthInfo >*
      mutable_auth_list();

  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.Internal.IMSyncAuthInfoRsp)
 private:
  inline void set_has_latest_time();
  inline void clear_has_latest_time();
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::AuthInfo > auth_list_;
  ::std::string* attach_data_;
  ::google::protobuf::uint32 latest_time_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eInternal_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eInternal_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eInternal_2eproto();
  friend void protobuf_ShutdownFile_IM_2eInternal_2eproto();

  void InitAsDefaultInstance();
  static IMSyncAuthInfoRsp* default_instance_;
};
// -------------------------------------------------------------------

class IMGetUserIdListByNickNameReq : public ::google::protobuf::MessageLite {
 public:
  IMGetUserIdListByNickNameReq();
  virtual ~IMGetUserIdListByNickNameReq();

  IMGetUserIdListByNickNameReq(const IMGetUserIdListByNickNameReq& from);

  inline IMGetUserIdListByNickNameReq& operator=(const IMGetUserIdListByNickNameReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const IMGetUserIdListByNickNameReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMGetUserIdListByNickNameReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMGetUserIdListByNickNameReq* other);

  // implements Message ----------------------------------------------

  IMGetUserIdListByNickNameReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMGetUserIdListByNickNameReq& from);
  void MergeFrom(const IMGetUserIdListByNickNameReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string nick_name_list = 1;
  inline int nick_name_list_size() const;
  inline void clear_nick_name_list();
  static const int kNickNameListFieldNumber = 1;
  inline const ::std::string& nick_name_list(int index) const;
  inline ::std::string* mutable_nick_name_list(int index);
  inline void set_nick_name_list(int index, const ::std::string& value);
  inline void set_nick_name_list(int index, const char* value);
  inline void set_nick_name_list(int index, const char* value, size_t size);
  inline ::std::string* add_nick_name_list();
  inline void add_nick_name_list(const ::std::string& value);
  inline void add_nick_name_list(const char* value);
  inline void add_nick_name_list(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& nick_name_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_nick_name_list();

  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.Internal.IMGetUserIdListByNickNameReq)
 private:
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> nick_name_list_;
  ::std::string* attach_data_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eInternal_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eInternal_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eInternal_2eproto();
  friend void protobuf_ShutdownFile_IM_2eInternal_2eproto();

  void InitAsDefaultInstance();
  static IMGetUserIdListByNickNameReq* default_instance_;
};
// -------------------------------------------------------------------

class IMGetUserIdListByNickNameRsp : public ::google::protobuf::MessageLite {
 public:
  IMGetUserIdListByNickNameRsp();
  virtual ~IMGetUserIdListByNickNameRsp();

  IMGetUserIdListByNickNameRsp(const IMGetUserIdListByNickNameRsp& from);

  inline IMGetUserIdListByNickNameRsp& operator=(const IMGetUserIdListByNickNameRsp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const IMGetUserIdListByNickNameRsp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const IMGetUserIdListByNickNameRsp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(IMGetUserIdListByNickNameRsp* other);

  // implements Message ----------------------------------------------

  IMGetUserIdListByNickNameRsp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const IMGetUserIdListByNickNameRsp& from);
  void MergeFrom(const IMGetUserIdListByNickNameRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .IM.BaseDefine.UserInfo user_info_list = 1;
  inline int user_info_list_size() const;
  inline void clear_user_info_list();
  static const int kUserInfoListFieldNumber = 1;
  inline const ::IM::BaseDefine::UserInfo& user_info_list(int index) const;
  inline ::IM::BaseDefine::UserInfo* mutable_user_info_list(int index);
  inline ::IM::BaseDefine::UserInfo* add_user_info_list();
  inline const ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::UserInfo >&
      user_info_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::UserInfo >*
      mutable_user_info_list();

  // optional bytes attach_data = 20;
  inline bool has_attach_data() const;
  inline void clear_attach_data();
  static const int kAttachDataFieldNumber = 20;
  inline const ::std::string& attach_data() const;
  inline void set_attach_data(const ::std::string& value);
  inline void set_attach_data(const char* value);
  inline void set_attach_data(const void* value, size_t size);
  inline ::std::string* mutable_attach_data();
  inline ::std::string* release_attach_data();
  inline void set_allocated_attach_data(::std::string* attach_data);

  // @@protoc_insertion_point(class_scope:IM.Internal.IMGetUserIdListByNickNameRsp)
 private:
  inline void set_has_attach_data();
  inline void clear_has_attach_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::UserInfo > user_info_list_;
  ::std::string* attach_data_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_IM_2eInternal_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_IM_2eInternal_2eproto();
  #endif
  friend void protobuf_AssignDesc_IM_2eInternal_2eproto();
  friend void protobuf_ShutdownFile_IM_2eInternal_2eproto();

  void InitAsDefaultInstance();
  static IMGetUserIdListByNickNameRsp* default_instance_;
};
// ===================================================================


// ===================================================================

// IMSyncAuthInfoReq

// required uint32 latest_time = 1;
inline bool IMSyncAuthInfoReq::has_latest_time() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMSyncAuthInfoReq::set_has_latest_time() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMSyncAuthInfoReq::clear_has_latest_time() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMSyncAuthInfoReq::clear_latest_time() {
  latest_time_ = 0u;
  clear_has_latest_time();
}
inline ::google::protobuf::uint32 IMSyncAuthInfoReq::latest_time() const {
  // @@protoc_insertion_point(field_get:IM.Internal.IMSyncAuthInfoReq.latest_time)
  return latest_time_;
}
inline void IMSyncAuthInfoReq::set_latest_time(::google::protobuf::uint32 value) {
  set_has_latest_time();
  latest_time_ = value;
  // @@protoc_insertion_point(field_set:IM.Internal.IMSyncAuthInfoReq.latest_time)
}

// optional bytes attach_data = 20;
inline bool IMSyncAuthInfoReq::has_attach_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMSyncAuthInfoReq::set_has_attach_data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMSyncAuthInfoReq::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMSyncAuthInfoReq::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& IMSyncAuthInfoReq::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.Internal.IMSyncAuthInfoReq.attach_data)
  return *attach_data_;
}
inline void IMSyncAuthInfoReq::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Internal.IMSyncAuthInfoReq.attach_data)
}
inline void IMSyncAuthInfoReq::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Internal.IMSyncAuthInfoReq.attach_data)
}
inline void IMSyncAuthInfoReq::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Internal.IMSyncAuthInfoReq.attach_data)
}
inline ::std::string* IMSyncAuthInfoReq::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Internal.IMSyncAuthInfoReq.attach_data)
  return attach_data_;
}
inline ::std::string* IMSyncAuthInfoReq::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMSyncAuthInfoReq::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Internal.IMSyncAuthInfoReq.attach_data)
}

// -------------------------------------------------------------------

// IMSyncAuthInfoRsp

// required uint32 latest_time = 1;
inline bool IMSyncAuthInfoRsp::has_latest_time() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMSyncAuthInfoRsp::set_has_latest_time() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMSyncAuthInfoRsp::clear_has_latest_time() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMSyncAuthInfoRsp::clear_latest_time() {
  latest_time_ = 0u;
  clear_has_latest_time();
}
inline ::google::protobuf::uint32 IMSyncAuthInfoRsp::latest_time() const {
  // @@protoc_insertion_point(field_get:IM.Internal.IMSyncAuthInfoRsp.latest_time)
  return latest_time_;
}
inline void IMSyncAuthInfoRsp::set_latest_time(::google::protobuf::uint32 value) {
  set_has_latest_time();
  latest_time_ = value;
  // @@protoc_insertion_point(field_set:IM.Internal.IMSyncAuthInfoRsp.latest_time)
}

// repeated .IM.BaseDefine.AuthInfo auth_list = 2;
inline int IMSyncAuthInfoRsp::auth_list_size() const {
  return auth_list_.size();
}
inline void IMSyncAuthInfoRsp::clear_auth_list() {
  auth_list_.Clear();
}
inline const ::IM::BaseDefine::AuthInfo& IMSyncAuthInfoRsp::auth_list(int index) const {
  // @@protoc_insertion_point(field_get:IM.Internal.IMSyncAuthInfoRsp.auth_list)
  return auth_list_.Get(index);
}
inline ::IM::BaseDefine::AuthInfo* IMSyncAuthInfoRsp::mutable_auth_list(int index) {
  // @@protoc_insertion_point(field_mutable:IM.Internal.IMSyncAuthInfoRsp.auth_list)
  return auth_list_.Mutable(index);
}
inline ::IM::BaseDefine::AuthInfo* IMSyncAuthInfoRsp::add_auth_list() {
  // @@protoc_insertion_point(field_add:IM.Internal.IMSyncAuthInfoRsp.auth_list)
  return auth_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::AuthInfo >&
IMSyncAuthInfoRsp::auth_list() const {
  // @@protoc_insertion_point(field_list:IM.Internal.IMSyncAuthInfoRsp.auth_list)
  return auth_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::AuthInfo >*
IMSyncAuthInfoRsp::mutable_auth_list() {
  // @@protoc_insertion_point(field_mutable_list:IM.Internal.IMSyncAuthInfoRsp.auth_list)
  return &auth_list_;
}

// optional bytes attach_data = 20;
inline bool IMSyncAuthInfoRsp::has_attach_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMSyncAuthInfoRsp::set_has_attach_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMSyncAuthInfoRsp::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMSyncAuthInfoRsp::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& IMSyncAuthInfoRsp::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.Internal.IMSyncAuthInfoRsp.attach_data)
  return *attach_data_;
}
inline void IMSyncAuthInfoRsp::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Internal.IMSyncAuthInfoRsp.attach_data)
}
inline void IMSyncAuthInfoRsp::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Internal.IMSyncAuthInfoRsp.attach_data)
}
inline void IMSyncAuthInfoRsp::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Internal.IMSyncAuthInfoRsp.attach_data)
}
inline ::std::string* IMSyncAuthInfoRsp::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Internal.IMSyncAuthInfoRsp.attach_data)
  return attach_data_;
}
inline ::std::string* IMSyncAuthInfoRsp::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMSyncAuthInfoRsp::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Internal.IMSyncAuthInfoRsp.attach_data)
}

// -------------------------------------------------------------------

// IMGetUserIdListByNickNameReq

// repeated string nick_name_list = 1;
inline int IMGetUserIdListByNickNameReq::nick_name_list_size() const {
  return nick_name_list_.size();
}
inline void IMGetUserIdListByNickNameReq::clear_nick_name_list() {
  nick_name_list_.Clear();
}
inline const ::std::string& IMGetUserIdListByNickNameReq::nick_name_list(int index) const {
  // @@protoc_insertion_point(field_get:IM.Internal.IMGetUserIdListByNickNameReq.nick_name_list)
  return nick_name_list_.Get(index);
}
inline ::std::string* IMGetUserIdListByNickNameReq::mutable_nick_name_list(int index) {
  // @@protoc_insertion_point(field_mutable:IM.Internal.IMGetUserIdListByNickNameReq.nick_name_list)
  return nick_name_list_.Mutable(index);
}
inline void IMGetUserIdListByNickNameReq::set_nick_name_list(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:IM.Internal.IMGetUserIdListByNickNameReq.nick_name_list)
  nick_name_list_.Mutable(index)->assign(value);
}
inline void IMGetUserIdListByNickNameReq::set_nick_name_list(int index, const char* value) {
  nick_name_list_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Internal.IMGetUserIdListByNickNameReq.nick_name_list)
}
inline void IMGetUserIdListByNickNameReq::set_nick_name_list(int index, const char* value, size_t size) {
  nick_name_list_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Internal.IMGetUserIdListByNickNameReq.nick_name_list)
}
inline ::std::string* IMGetUserIdListByNickNameReq::add_nick_name_list() {
  return nick_name_list_.Add();
}
inline void IMGetUserIdListByNickNameReq::add_nick_name_list(const ::std::string& value) {
  nick_name_list_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:IM.Internal.IMGetUserIdListByNickNameReq.nick_name_list)
}
inline void IMGetUserIdListByNickNameReq::add_nick_name_list(const char* value) {
  nick_name_list_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:IM.Internal.IMGetUserIdListByNickNameReq.nick_name_list)
}
inline void IMGetUserIdListByNickNameReq::add_nick_name_list(const char* value, size_t size) {
  nick_name_list_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:IM.Internal.IMGetUserIdListByNickNameReq.nick_name_list)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
IMGetUserIdListByNickNameReq::nick_name_list() const {
  // @@protoc_insertion_point(field_list:IM.Internal.IMGetUserIdListByNickNameReq.nick_name_list)
  return nick_name_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
IMGetUserIdListByNickNameReq::mutable_nick_name_list() {
  // @@protoc_insertion_point(field_mutable_list:IM.Internal.IMGetUserIdListByNickNameReq.nick_name_list)
  return &nick_name_list_;
}

// optional bytes attach_data = 20;
inline bool IMGetUserIdListByNickNameReq::has_attach_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMGetUserIdListByNickNameReq::set_has_attach_data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMGetUserIdListByNickNameReq::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMGetUserIdListByNickNameReq::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& IMGetUserIdListByNickNameReq::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.Internal.IMGetUserIdListByNickNameReq.attach_data)
  return *attach_data_;
}
inline void IMGetUserIdListByNickNameReq::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Internal.IMGetUserIdListByNickNameReq.attach_data)
}
inline void IMGetUserIdListByNickNameReq::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Internal.IMGetUserIdListByNickNameReq.attach_data)
}
inline void IMGetUserIdListByNickNameReq::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Internal.IMGetUserIdListByNickNameReq.attach_data)
}
inline ::std::string* IMGetUserIdListByNickNameReq::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Internal.IMGetUserIdListByNickNameReq.attach_data)
  return attach_data_;
}
inline ::std::string* IMGetUserIdListByNickNameReq::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMGetUserIdListByNickNameReq::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Internal.IMGetUserIdListByNickNameReq.attach_data)
}

// -------------------------------------------------------------------

// IMGetUserIdListByNickNameRsp

// repeated .IM.BaseDefine.UserInfo user_info_list = 1;
inline int IMGetUserIdListByNickNameRsp::user_info_list_size() const {
  return user_info_list_.size();
}
inline void IMGetUserIdListByNickNameRsp::clear_user_info_list() {
  user_info_list_.Clear();
}
inline const ::IM::BaseDefine::UserInfo& IMGetUserIdListByNickNameRsp::user_info_list(int index) const {
  // @@protoc_insertion_point(field_get:IM.Internal.IMGetUserIdListByNickNameRsp.user_info_list)
  return user_info_list_.Get(index);
}
inline ::IM::BaseDefine::UserInfo* IMGetUserIdListByNickNameRsp::mutable_user_info_list(int index) {
  // @@protoc_insertion_point(field_mutable:IM.Internal.IMGetUserIdListByNickNameRsp.user_info_list)
  return user_info_list_.Mutable(index);
}
inline ::IM::BaseDefine::UserInfo* IMGetUserIdListByNickNameRsp::add_user_info_list() {
  // @@protoc_insertion_point(field_add:IM.Internal.IMGetUserIdListByNickNameRsp.user_info_list)
  return user_info_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::UserInfo >&
IMGetUserIdListByNickNameRsp::user_info_list() const {
  // @@protoc_insertion_point(field_list:IM.Internal.IMGetUserIdListByNickNameRsp.user_info_list)
  return user_info_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::IM::BaseDefine::UserInfo >*
IMGetUserIdListByNickNameRsp::mutable_user_info_list() {
  // @@protoc_insertion_point(field_mutable_list:IM.Internal.IMGetUserIdListByNickNameRsp.user_info_list)
  return &user_info_list_;
}

// optional bytes attach_data = 20;
inline bool IMGetUserIdListByNickNameRsp::has_attach_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMGetUserIdListByNickNameRsp::set_has_attach_data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMGetUserIdListByNickNameRsp::clear_has_attach_data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMGetUserIdListByNickNameRsp::clear_attach_data() {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_->clear();
  }
  clear_has_attach_data();
}
inline const ::std::string& IMGetUserIdListByNickNameRsp::attach_data() const {
  // @@protoc_insertion_point(field_get:IM.Internal.IMGetUserIdListByNickNameRsp.attach_data)
  return *attach_data_;
}
inline void IMGetUserIdListByNickNameRsp::set_attach_data(const ::std::string& value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set:IM.Internal.IMGetUserIdListByNickNameRsp.attach_data)
}
inline void IMGetUserIdListByNickNameRsp::set_attach_data(const char* value) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:IM.Internal.IMGetUserIdListByNickNameRsp.attach_data)
}
inline void IMGetUserIdListByNickNameRsp::set_attach_data(const void* value, size_t size) {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  attach_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:IM.Internal.IMGetUserIdListByNickNameRsp.attach_data)
}
inline ::std::string* IMGetUserIdListByNickNameRsp::mutable_attach_data() {
  set_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    attach_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:IM.Internal.IMGetUserIdListByNickNameRsp.attach_data)
  return attach_data_;
}
inline ::std::string* IMGetUserIdListByNickNameRsp::release_attach_data() {
  clear_has_attach_data();
  if (attach_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = attach_data_;
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void IMGetUserIdListByNickNameRsp::set_allocated_attach_data(::std::string* attach_data) {
  if (attach_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete attach_data_;
  }
  if (attach_data) {
    set_has_attach_data();
    attach_data_ = attach_data;
  } else {
    clear_has_attach_data();
    attach_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:IM.Internal.IMGetUserIdListByNickNameRsp.attach_data)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace Internal
}  // namespace IM

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_IM_2eInternal_2eproto__INCLUDED
